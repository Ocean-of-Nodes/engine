//! This crate is the `cpp` cargo build script implementation. It is useless
//! without the companion crates `cpp`, and `cpp_macro`.
//!
//! For more information, see the [`cpp` crate module level
//! documentation](https://docs.rs/cpp).

#![allow(clippy::write_with_newline)]

extern crate cc;
extern crate cpp_common;
extern crate proc_macro2;
extern crate regex;
extern crate syn;
extern crate unicode_xid;

#[macro_use]
extern crate lazy_static;

#[macro_use]
mod strnom;

use cpp_common::*;
use std::collections::hash_map::{Entry, HashMap};
use std::env;
use std::fs::{create_dir, remove_dir_all, File};
use std::io::prelude::*;
use std::path::{Path, PathBuf};

mod parser;

fn warnln_impl(a: &str) {
    for s in a.lines() {
        println!("cargo:warning={}", s);
    }
}

macro_rules! warnln {
    ($($all:tt)*) => {
        $crate::warnln_impl(&format!($($all)*));
    }
}

// Like the write! macro, but add the #line directive (pointing to this file).
// Note: the string literal must be on on the same line of the macro
macro_rules! write_add_line {
    ($o:expr, $($e:tt)*) => {
        (|| {
            writeln!($o, "#line {} \"{}\"", line!(), file!().replace('\\', "\\\\"))?;
            write!($o, $($e)*)
        })()
    };
}

const INTERNAL_CPP_STRUCTS: &str = r#"
/* THIS FILE IS GENERATED BY rust-cpp. DO NOT EDIT */

#include "stdint.h" // For {u}intN_t
#include <new> // For placement new
#include <cstdlib> // For abort
#include <type_traits>
#include <utility>

namespace rustcpp {

// We can't just pass or return any type from extern "C" rust functions (because the call
// convention may differ between the C++ type, and the Rust type).
// So we make sure to pass trivial structure that only contains a pointer to the object we want to
// pass. The constructor of these helper class contains a 'container' of the right size which will
// be allocated on the stack.
template<typename T> struct return_helper {
    struct container {
#if defined (_MSC_VER) && (_MSC_VER + 0 < 1900)
        char memory[sizeof(T)];
        ~container() { reinterpret_cast<T*>(this)->~T(); }
#else
        // The fact that it is in an union means it is properly sized and aligned, but we have
        // to call the destructor and constructor manually
        union { T memory; };
        ~container() { memory.~T(); }
#endif
        container() {}
    };
    const container* data;
    return_helper(int, const container &c = container()) : data(&c) { }
};

template<typename T> struct argument_helper {
    using type = const T&;
};
template<typename T> struct argument_helper<T&> {
    T &ref;
    argument_helper(T &x) : ref(x) {}
    using type = argument_helper<T&> const&;
};

template<typename T>
typename std::enable_if<std::is_copy_constructible<T>::value>::type copy_helper(const void *src, void *dest)
{ new (dest) T (*static_cast<T const*>(src)); }
template<typename T>
typename std::enable_if<!std::is_copy_constructible<T>::value>::type copy_helper(const void *, void *)
{ std::abort(); }
template<typename T>
typename std::enable_if<std::is_default_constructible<T>::value>::type default_helper(void *dest)
{ new (dest) T(); }
template<typename T>
typename std::enable_if<!std::is_default_constructible<T>::value>::type default_helper(void *)
{ std::abort(); }

template<typename T> int compare_helper(const T &a, const T&b, int cmp) {
    switch (cmp) {
        using namespace std::rel_ops;
        case 0:
            if (a < b)
                return -1;
            if (b < a)
                return 1;
            return 0;
        case -2: return a < b;
        case 2: return a > b;
        case -1: return a <= b;
        case 1: return a >= b;
    }
    std::abort();
}
}

#define RUST_CPP_CLASS_HELPER(HASH, ...) \
    extern "C" { \
    void __cpp_destructor_##HASH(void *ptr) { typedef __VA_ARGS__ T; static_cast<T*>(ptr)->~T(); } \
    void __cpp_copy_##HASH(const void *src, void *dest) { rustcpp::copy_helper<__VA_ARGS__>(src, dest); } \
    void __cpp_default_##HASH(void *dest) { rustcpp::default_helper<__VA_ARGS__>(dest); } \
    }
"#;

lazy_static! {
    pub static ref CPP_DIR: PathBuf = OUT_DIR.join("rust_cpp");
    static ref CARGO_MANIFEST_DIR: PathBuf = PathBuf::from(env::var("CARGO_MANIFEST_DIR").expect(
        r#"
-- rust-cpp fatal error --

The CARGO_MANIFEST_DIR environment variable was not set.
NOTE: rust-cpp's build function must be run in a build script."#
    ));
}

fn gen_cpp_lib(visitor: &parser::Parser) -> PathBuf {
    let result_path = CPP_DIR.join("cpp_closures.cpp");
    let mut output = File::create(&result_path).expect("Unable to generate temporary C++ file");

    write!(output, "{}", INTERNAL_CPP_STRUCTS).unwrap();

    if visitor.callbacks_count > 0 {
        #[rustfmt::skip]
        write_add_line!(output, r#"
extern "C" {{
    void (*rust_cpp_callbacks{file_hash}[{callbacks_count}])() = {{}};
}}
        "#,
            file_hash = *FILE_HASH,
            callbacks_count = visitor.callbacks_count
        ).unwrap();
    }

    write!(output, "{}\n\n", &visitor.snippets).unwrap();

    let mut hashmap = HashMap::new();

    let mut sizealign = vec![];
    for &Closure {
        ref body_str,
        ref sig,
        ref callback_offset,
        ..
    } in &visitor.closures
    {
        let &ClosureSig {
            ref captures,
            ref cpp,
            ..
        } = sig;

        let hash = sig.name_hash();
        let name = sig.extern_name();

        match hashmap.entry(hash) {
            Entry::Occupied(e) => {
                if *e.get() != sig {
                    // Let the compiler do a compilation error. FIXME: report a better error
                    warnln!("Hash collision detected.");
                } else {
                    continue;
                }
            }
            Entry::Vacant(e) => {
                e.insert(sig);
            }
        }

        let is_void = cpp == "void";

        // Generate the sizes array with the sizes of each of the argument types
        if is_void {
            sizealign.push(format!(
                "{{{hash}ull, 0, 1, {callback_offset}ull << 32}}",
                hash = hash,
                callback_offset = callback_offset
            ));
        } else {
            sizealign.push(format!("{{
                {hash}ull,
                sizeof({type}),
                rustcpp::AlignOf<{type}>::value,
                rustcpp::Flags<{type}>::value | {callback_offset}ull << 32
            }}", hash=hash, type=cpp, callback_offset = callback_offset));
        }
        for &Capture { ref cpp, .. } in captures {
            sizealign.push(format!("{{
                {hash}ull,
                sizeof({type}),
                rustcpp::AlignOf<{type}>::value,
                rustcpp::Flags<{type}>::value
            }}", hash=hash, type=cpp));
        }

        // Generate the parameters and function declaration
        let params = captures
            .iter()
            .map(
                |&Capture {
                     mutable,
                     ref name,
                     ref cpp,
                 }| {
                    if mutable {
                        format!("{} & {}", cpp, name)
                    } else {
                        format!("{} const& {}", cpp, name)
                    }
                },
            )
            .collect::<Vec<_>>()
            .join(", ");

        if is_void {
            #[rustfmt::skip]
            write_add_line!(output, r#"
extern "C" {{
void {name}({params}) {{
{body}
}}
}}
"#,
                name = &name,
                params = params,
                body = body_str
            ).unwrap();
        } else {
            let comma = if params.is_empty() { "" } else { "," };
            let args = captures
                .iter()
                .map(|&Capture { ref name, .. }| name.to_string())
                .collect::<Vec<_>>()
                .join(", ");
            #[rustfmt::skip]
            write_add_line!(output, r#"
static inline {ty} {name}_impl({params}) {{
{body}
}}
extern "C" {{
void {name}({params}{comma} void* __result) {{
    ::new(__result) ({ty})({name}_impl({args}));
}}
}}
"#,
                name = &name,
                params = params,
                comma = comma,
                ty = cpp,
                args = args,
                body = body_str
            ).unwrap();
        }
    }

    for class in &visitor.classes {
        let hash = class.name_hash();

        // Generate the sizes array
        sizealign.push(format!("{{
                {hash}ull,
                sizeof({type}),
                rustcpp::AlignOf<{type}>::value,
                rustcpp::Flags<{type}>::value
            }}", hash=hash, type=class.cpp));

        // Generate helper function.
        // (this is done in a macro, which right after a #line directing pointing to the location of
        // the cpp_class! macro in order to give right line information in the possible errors)
        write!(
            output,
            "{line}RUST_CPP_CLASS_HELPER({hash}, {cpp_name})\n",
            line = class.line,
            hash = hash,
            cpp_name = class.cpp
        )
        .unwrap();

        if class.derives("PartialEq") {
            write!(output,
                "{line}extern \"C\" bool __cpp_equal_{hash}(const {name} *a, const {name} *b) {{ return *a == *b; }}\n",
                line = class.line, hash = hash, name = class.cpp).unwrap();
        }
        if class.derives("PartialOrd") {
            write!(output,
                "{line}extern \"C\" bool __cpp_compare_{hash}(const {name} *a, const {name} *b, int cmp) {{ return rustcpp::compare_helper(*a, *b, cmp); }}\n",
                line = class.line, hash = hash, name = class.cpp).unwrap();
        }
    }

    let mut magic = vec![];
    for mag in STRUCT_METADATA_MAGIC.iter() {
        magic.push(format!("{}", mag));
    }

    #[rustfmt::skip]
    write_add_line!(output, r#"

namespace rustcpp {{

template<typename T>
struct AlignOf {{
    struct Inner {{
        char a;
        T b;
    }};
    static const uintptr_t value = sizeof(Inner) - sizeof(T);
}};

template<typename T>
struct Flags {{
    static const uintptr_t value =
        (std::is_copy_constructible<T>::value << {flag_is_copy_constructible}) |
        (std::is_default_constructible<T>::value << {flag_is_default_constructible}) |
#if !defined(__GNUC__) || (__GNUC__ + 0 >= 5) || defined(__clang__)
        (std::is_trivially_destructible<T>::value << {flag_is_trivially_destructible}) |
        (std::is_trivially_copyable<T>::value << {flag_is_trivially_copyable}) |
        (std::is_trivially_default_constructible<T>::value << {flag_is_trivially_default_constructible}) |
#endif
        0;
}};

struct SizeAlign {{
    uint64_t hash;
    uint64_t size;
    uint64_t align;
    uint64_t flags;
}};

struct MetaData {{
    uint8_t magic[128];
    uint8_t version[16];
    uint64_t length;
    SizeAlign data[{length}];
}};

MetaData
#ifdef _WIN32
    __declspec (selectany)
#elif __GNUC__
    __attribute__((weak))
#endif
    metadata = {{
    {{ {magic} }},
    "{version}",
    {length},
    {{ {data} }}
}};

}} // namespace rustcpp
"#,
        data = sizealign.join(", "),
        length = sizealign.len(),
        magic = magic.join(", "),
        version = VERSION,
        flag_is_copy_constructible = flags::IS_COPY_CONSTRUCTIBLE,
        flag_is_default_constructible = flags::IS_DEFAULT_CONSTRUCTIBLE,
        flag_is_trivially_destructible = flags::IS_TRIVIALLY_DESTRUCTIBLE,
        flag_is_trivially_copyable = flags::IS_TRIVIALLY_COPYABLE,
        flag_is_trivially_default_constructible = flags::IS_TRIVIALLY_DEFAULT_CONSTRUCTIBLE,
    ).unwrap();

    result_path
}

fn clean_artifacts() {
    if CPP_DIR.is_dir() {
        remove_dir_all(&*CPP_DIR).expect(
            r#"
-- rust-cpp fatal error --

Failed to remove existing build artifacts from output directory."#,
        );
    }

    create_dir(&*CPP_DIR).expect(
        r#"
-- rust-cpp fatal error --

Failed to create output object directory."#,
    );
}


/// Extracts `cpp` declarations from the passed-in crate root, and 
/// collect its into `cpp_closures.cpp` file.
///
/// This method does not perform rust codegen - that is performed by `cpp`
/// and `cpp_macros`, which perform the actual procedural macro expansion.
pub fn create_lib<P: AsRef<Path>>(crate_root: P) -> Option<PathBuf> {
    // It is used for check packages compatibility. Because in 
    // future some implementations details can be changed 
    assert_eq!(
        env!("CARGO_PKG_VERSION"),
        VERSION,
        "Internal Error: mismatched cpp_common and cpp_build versions"
    );

    // Clean up any leftover artifacts
    clean_artifacts();

    // Parse the crate
    let mut visitor = parser::Parser::default();
    // By `better error message,` we mean that if parser provided by crate  
    // can't parse something than rustc also will have problems with it
    // and we leaves error handling to it
    if let Err(err) = visitor.parse_crate(crate_root.as_ref().to_owned()) {
        warnln!(
            r#"
-- rust-cpp parse error --

There was an error parsing the crate for the rust-cpp build script:
{}
In order to provide a better error message, the build script will exit successfully, such that rustc can provide an error message."#,
            err
        );
        return None;
    }
    
    // Generate the C++ library code 
    let filename = gen_cpp_lib(&visitor); 
    println!("aggregate inserts - crate: {} target: {}", crate_root.as_ref().to_string_lossy(), filename.to_string_lossy());
    Some(filename)
}

